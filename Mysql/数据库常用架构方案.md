### 数据库常用架构方案

##### 常见的架构方案

- 主备架构，只有主库提供读写服务，备库冗余做故障转移
- 双主架构，两个主库同时提供服务，负载均衡
- 主从架构，一主多从，读写分离
- 双主 + 主从架构   相对来说比较完美

##### 一致性解决方案

- 主从双库一致性解决方案
- DB和缓存一致性解决方案

#### 常见的架构方案

##### 方案一：主备  

​	神雕项目使用的就是主备架构，建立了索引

##### 方案二：双主架构

- 高可用分析：一个主库挂了，不影响另外一台主库提供服务
- 一致性分析：存在数据一致性问题
- 可落地分析：1、数据一致性问题，一致性解决方案可解决问题；2、主键冲突，ID统一由分布式ID生成服务来生成可以解决该问题

##### 方案三：主从架构

- 高可用分析：主库单点，从库高可用，一单主库挂了写服务就无法提供
- 一致性分析：同上
- 扩展性分析：加从库增加可读性(带来的问题，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间会很长)
- 可落地分析：1、数据一致性；2、主库单点问题

##### 方案四：双主+主从

- 一致性分析：存在数据一致性问题
- 可扩展分析：可以通过加从库来扩展读性能，进而提高整体性能

#### 一致性解决方案

##### 第一类：主库和从库一致性解决方案

**数据不一致问题的解决方案：**

1. 直接忽略，如果业务允许延时存在，那么就不去管它
2. 强制读主，采用主备架构方案，读写都走主库。用缓存来扩展数据库读性能。如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的
3. 选择读主，写操作时根据库 + 表 +业务特征生成一个key放到缓存里，并设置超时时间(大于等于主从数据同步时间)。读请求时，同样的方式生成key先查询缓存，在判断是否命中，如果命中，则读主库，否则读从库
4. 半同步复制，等主从同步完成，写请求才返回。就是大家常说的“半同步复制”。这可以利用数据库原生功能，实现比较简单。代价是写请求时延增长，吞吐量降低。
5. 数据库中间件，引入开元Mycat

##### 第二类：DB和缓存一致性解决方案

**缓存使用方式**

1. 淘汰缓存
2. 写入数据库
3. 读取缓存？如果缓存不存在，读数据库
4. 读数据库后写入缓存

**读写都在主库的话，采用该缓存方案，不会存在一致性问题；读从写主库，在主从同步的时间段内，如果还未同步完成，那么这个时候去读从库，会读出脏数据，加载到内存中，缓存中的数据可能就一直是脏数据了，所以解决方案是设置缓存时，一定要加上失效时间，以防延时淘汰缓存失败的情况。设置的这个失效时间应该大于主从同步时间。**

[数据库常用架构方案](https://www.cnblogs.com/littlecharacter/p/9084291.html#m5)

