# Effective C++

## 自己习惯C++

### static的作用

如果是全局变量，声明变量只在本文件的作用域内生效。

如果是局部变量，变量只会初始化一次。

如果是C++的成员函数或者成员变量，声明函数或者变量只有一份，多个类实例共享这份数据。

### \#define和const的区别

- #define是宏定义，const是语言特性
- \#define在预处理阶段会进行文本替换，const在编译阶段生效
- 由于#define在预处理阶段已经进行了文本替换，所以如果编译时涉及到这部分代码，编译信息只会显示处理后的信息，不会显示原来宏的信息，造成追踪困难。
- 每个用到宏的地方都会进行一次文本替换，导致出现多份。而const只有一个。
- \#define对作用域失效

### 尽可能使用const

- const在*号左边，表示被指物是常量
- const在*号右边，表示指针是常量
- 如果一个成员函数被定义为const，则无法修改成员变量的值,可以定义成员变量为mutable，则可以让const函数修改

### 传参尽量传递const引用

这样可以减少一次值拷贝，通知避免对参数进行修改。

## 构造/析构/赋值运算

### C++成员变量存储和初始化

c++成员会按照定义的顺序进行存储和初始化。

### C++默认编写的构造函数

- 如果没有定义构造函数，拷贝构造函数，赋值操作符，那么如果有调用的地方，编译器会自动声明。
- 如果声明了不同参数的构造函数，编译器不会再声明default构造函数

### 显式禁止编译器自动生成构造函数

编译器自动生成的构造函数都是public,将拷贝构造函数和赋值操作符声明成private，并且不实现，可以显式的禁止调用。

### 为多态基类声明virtual析构函数

多态析构时能够找到对应继承类的析构函数，进行资源释放，防止资源无法释放

### 纯虚函数可以有定义，但是接口类无法实例化

可以定义纯虚函数，但是不能进行实例化。

### 不要在构造和析构过程中调用virtual函数

因为当在基类的构造函数调用virtual函数的时候，此时继承类的virtual函数还没实现，最终编译器会调用基类的virtual函数。

### 令operator=返回reference to *this

可以减少复制

### 拷贝构造函数以及赋值操作符应确保拷贝了对象所有的成员以及所有基类的部分

## 资源管理

### RAII(资源获取即初始化)

当使用完时，通过析构函数释放资源。复制RAII对象的时候，必须一并复制它管理的资源。

### new和delete使用时要采用相同的形式

- 当new一个对象的时候，delete一个对象；
- 当new 一个数组的时候，delete一个数组。

### 将new语句单独写成一句

否则可能导致崩溃时没法调用析构函数，导致内存泄露。

## 设计与声明

### 函数传值

- 对于类对象来说，传递常引用比传值效率高，可以减少一次拷贝。
- 但对于内置类型，迭代器以及函数对象来说，直接传值效率更高。

### 不要返回局部变量的指针或者引用

（c++11中，可以直接返回局部变量的右值引用，某些返回值优化的编译器，实质也是将局部变量地址返回），所以尽管内部实现返回的是引用，但是实际编码不能返回引用

### C++4种转换

- const_cast：将对象的常量性移除
- dynamic_cast：安全向下转型，将基类转换成继承类，如果转换失败，返回nullptr
- reinterpret_cast：低级转换
- static_cast：强迫隐式转换

### inline的优缺点

- 将函数的调用用函数本体替换，这样就减少了寻址和入栈出栈的操作。
- 但是如果太多的inline将导致程序体积太大，降低告诉缓存的命中率。
- virtual函数无法使用内联，因为virtual函数只有在运行时才能确定下来。

## 继承与面向对象

### 如果继承类以public继承基类，那么继承类和基类之间是is-a的关系，即继承类是基类

### 重载，覆盖和隐藏

- 重载指一个类中函数名相同，但是函数参数和返回值不一样，c++会编译成两个不同的函数
- 覆盖指继承类的函数重写了基类的函数，这类函数要声明为虚函数
- 隐藏指如果继承类中声明了和基类中同名的函数（不管参数和返回值是否一样），基类中的函数在继承类中不可见
- 继承类中使用using显式声明可以解决函数隐藏不可见的问题。

### 静态类型和动态类型

- 静态类型就是声明时的类型

- 动态类型时对象当前的类型

- 对于多态来说，静态类型就是基类类型，而动态类型就是运行时继承类的类型

### 多重继承

- 为避免钻石继承，采用public virtual的继承。
- 避免在virtual base中存放数据。

## 模板与泛型编程

### 隐式接口和编译期多态

- 面向对象是以显式接口和动态绑定实现的
- 模板是以隐式接受和静态绑定实现的