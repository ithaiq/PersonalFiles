### 服务器架构

**服务器类型：游戏服，连接服，数据服，大小跨服，社交服，平台服，中心服**

1. 架构:分布式架构，RPC通信，ZMQ作为RPC通信中间件，类似于长连接
2. 游戏服：通过配置文件，决定游戏服的数量，可以将游戏和场景单独开服分离，如果开启多个，需要通过ZMQ相互连接
3. 连接服：通过配置文件，决定游戏服的数量，可以开启在游戏服中，也可以单独开启，如果要单独开启，游戏服在启动时，发起远程Node连接过程。后期通信方式，也是通过RPC，查看是否在相同Node，决定call调用方式
4. 数据服:同连接服。开启两个服务，DPPart，DBline，异步写数据到DB中
5. 其他服务器都一样的流程，没有特别，都是单独起的



#### 自研RPC

##### 角色

- 生产者:调用发起方
- 消费者:远程服务Port
- 注册中心：服务器启动时，固定读取配置文件，记录相互连接的Node，下属的Port，Service
- 通信协议：ZMQ的Push和Pull
- 处理方式，优先放入buffer中，使用PB序列化，放入ZMQ中
- 在Port中有Call的调用信息统计，也就是接口调用次数统计

##### 流程

1. 先创建服务的实例，实例中可以通过服务名字，查找配置文件导入的config.java中的map，流程大概是serviceName -> portId -> NodeId，找到其中的远程Node，Port
2. 创建inst ，包含远程服务的信息和调用方服务的信息(Node,Port，Service)
3. 发起RPC，实际为静态代理模式，包装调用信息为call
4. 通过服务器架构，也就是调用方和远程服务方是否在同Node下，走不同的调用策略
5. 将call通过直接线程间通信(ZMQ)，放入远程服务所属的Port中
6. 异步返回值的调用，是通过Port中生成的一个callId，关联call调用，call中携带异步返回的结果，通过方法回调的方式，处理异步返回结果
7. call的执行 
   1. // 获取对应的代理类  
   2. // 通过代理类 获取函数引用
   3. 通过反射，执行远程调用服务的接口
8. call中通过returans，把远程服务接口的结果包装成call，从远程服务中，返回到服务调用方
9. 本地Port中，执行步骤6的后半部分，由于通过id关联了发起的call和callreturn，可以一一对应