### 线程池原理与使用

#### 线程导读


##### 用户线程（ULT）

​	在用户程序中实现的线程，不依赖操作系统，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。因此一个线程阻塞将使得整个进程阻塞。

##### 用户空间

​	app，JVM，360等在用户空间中运行

##### 内核线程（KLT）

​	线程的所有管理操作由操作系统内核完成。内核保存线程的状态和上下文信息，线程阻塞不会引气进程阻塞。在多处理器系统上，内核可以分派属于统一进程的多个线程在多个处理器上运行。线程创建调度和管理由内核完成。

#### Thread重要方法
- start()，调用该方法开始执行该线程
- stop()，调用该方法强制结束线程执行
- join()，调用该方法等待该线程结束
- sleep(),调用该方法该线程进入等待
- run(),调用该方法直接执行线程的run()方法，但是线程调用start()方法时，也是会运行run()的，**区别在于一个是由线程调度运行run(),一个是直接调用了线程中的run()**

#### 线程状态

```java
   新建状态   ---->  就绪状态(start之后，线程在睡眠或者挂起中回复也会进入)
       					∨
      阻塞状态（线程被暂停，如sleep）  < ----- 运行状态(run)  ------> 死亡状态
```
#### JAVA线程池

​	JVM中的线程依赖于操作系统，属于内核线程，java中的创建一个java线程，通过库调度器，与内核线程1:1的对应关系，是维护了一个线程表(内核线程，操作系统调度器)。Thread.start（）之后，只是标志线程Ready状态，内核线程在创建之后，等待获取CPU，进入Running状态。

​		线程上下文切换和调度浪费资源。

##### 线程生命周期

- new Thread 创建了一个java对象
- start()执行，进入RUNNABLE状态，进入就绪状态(READY)等待CPU调度
- CPU调度 yield()，进入运行中(RUNNING)
- 执行完成进入终止完成或者
- 阻塞和等待。。。。。。

##### 什么时候使用线程池？

- 单个任务处理时间段
- 需要处理的任务数量很大





